PRINTF(3) - Руководство по функциям библиотеки

# NAME

**`printf`**, **`fprintf`**, **`sprintf`**, **`snprintf`**, **`asprintf`**, **`dprintf`**,
**`vprintf`**, **`vfprintf`, `vsprintf`**, **`vsnprintf`**, **`vasprintf`, `vdprintf`** - преобразование форматированного вывода

# LIBRARY

Standard C Library (libc,-lc)

# SYNOPSIS

```C
#include <stdio.h>

int printf(const char * restrict format, ...);

int fprintf(FILE * restrict stream, const char * restrict format, ...);

int sprintf(char * restrict str, const char * restrict format, ...);

int snprintf(char * restrict str, *ize_t size, const char * restrict format, ...);

int asprintf(char **ret, const char *format, ...);

int dprintf(int fd, const char * restrict format, ...);

#include <stdarg.h>

int vprintf(const char * restrict format, va_list ap);

int vfprintf(FILE * restrict stream, const char * restrict format, va_list ap*);

int vsprintf(char * restrict str, const char * restrict format, va_list ap*);

int vsnprintf(char * restrict str, size_t size, const char * restrict format, va_list ap);

int vasprintf(char **ret, const char *format, va_list ap);

int vdprintf(int fd, const char * restrict format, va_list ap);
```

# ОПИСАНИЕ
Семейство функций **`printf`**() производит вывод в соответствии с *`format`*, как описано ниже. Функции **`printf`**() и **`vprintf`**() пишут вывод в `stdout`, поток стандартного вывода; **`fprintf`**() и **`vfprintf`**() записываают вывод в заданный поток *`stream`*; **`dprintf`**() и **`vdprintf`**() записывают вывод в звданный файловый дескриптор; **`sprintf`**(), **`snprintf`**(), **`vsprintf`**(), и **`vsnprintf`**() записываю результат в строковую переменну *`str`*; а **`asprintf`**() и **`vasprintf`**() динамично выделяют память с помощью malloc(3) для новой строки с результатом.

Расширенные локальные версии этих функций описаны в printf\_l(3). Смотрите также xlocale(3) для большей информации.

Эти функции записывают выходные данные под управлением строки *`format`*, которая указывает, как последующие аргументы (или аргументы, доступные через средства аргументов переменной длины из stdarg(3)) преобразуются для вывода.

Функции **`asprintf`**() и **` vasprintf`**() устанавливают *`* ret`* как указатель на буфер, достаточно большой для хранения отформатированной строки. Этот указатель должен быть передан free(3), чтобы освободить выделенное хранилище, когда оно больше не нужно. Если достаточное пространство не может быть выделено, **`asprintf`**() и **`vasprintf`**() вернут -1 и установят указатель *`ret`* как `NULL`.

Функции **`snprintf`**() и **`vsnprintf`**() запишут не более *`size`* -1 символов, напечатанных в выходной строке (*`size`* '-й символ затем получает завершающий символ '`\0`'); если возвращаемое значение больше или равно аргументу *`size`*, т.е. строка оказалась слишком короткой то некоторые из напечатанных символов отбрасываются. Вывод всегда заканчивается нулем, если *`size`* не равен 0.

Функции **`sprintf`**() и **`vsprintf`**() работают с *`size`* равной `INT_MAX + 1`. (**_`???`_**)

Для тех подпрограмм, которые записывают в предоставленную пользователем строку символов, эта строка и строки формата не должны перекрываться, поскольку поведение не определено.

Строка формата состоит из нуля или более директив: обычные символы (не **`%`**), которые копируются без изменений в выходной поток; и спецификации преобразования, каждая из которых приводит к получению нуля или более последующих аргументов. Каждая спецификация преобразования представлена ​​символом **`%`**. Аргументы должны соответствовать (после продвижения типа) спецификатору преобразования. После **`%`** в последовательности появляется следующее:

* Необязательное поле, состоящее из десятичной строки, за которой следует **`$`**, указывающее следующий аргумент для доступа. Если это поле не предоставлено, будет использован аргумент, следующий за последним доступным аргументом. Аргументы нумеруются начиная с **`1`**. Если в строке форматирования недоступные аргументы перемежаются с доступными аргументами, результаты будут неопределенными.

* Ноль или более из следующих флагов:  
  '**`#`**'  
		Значение должно быть преобразовано в «альтернативную форму». Для **`c`**, **`d`**, **`i`**, **`n`**, **`p`**, **`s`**, и **`u`** эта опция не имеет никакого эффекта. Для преобразований **o** точность числа увеличивается, чтобы заставить первый символ выходной строки обнуляться. Для преобразований **`x`** и **`X`** ненулевой результат имеет строку '`0x`' (или '`0X`' для преобразований **`X`**), добавленную перед резуультатом. Для **`a`**, **`A`**, **`e`**, **`E`**, **`f`**, **`F`**, **`g`** и **`G`** преобразований результат всегда будет содержать десятичную точку, даже если за ней не следуют никакие цифры (обычно десятичная точка появляется в результатах этих преобразований, только если следует цифра). Для преобразований **`g`** и **`G`** конечные нули не удаляются из результата, как это было бы в противном случае.  
  '**`0`**' (ноль)  
		Нулевое заполнение. Для всех преобразований, кроме **`n`**, преобразованное значение дополняется слева нулями, а не пробелами. Если задана точность с числовым преобразованием (**`d`**, **`i`**, **`o`**, **`u`**, **`i`**, **`x`** и **`X`**), флаг **0** игнорируется.  
  '**`-`**'  
		Флаг отрицательной ширины поля; преобразованное значение должно быть отрегулировано на границе поля. За исключением **n** преобразований, преобразованное значение дополняется справа пробелами, а не слева пробелами или нулями.
		A **`-`** отменяет **`0`**, если оба даны.  
  **' '** (пробел)  
		Пробел должен быть оставлен до положительного числа, полученного в результате преобразования со знаком (**`a`**, **`A`**, **`d`**, **`e`**, **` E`**, **`f`**, **`F`**, **`g`**, **`G`** или **`i`**).  
  '**`~`**'  
		Знак всегда должен быть помещен перед номером, произведенным подписанным преобразованием. A **`+`** перекрывает пробел, если используются оба.  
  '`'`' (апостроф)  
		Десятичные преобразования (**`d`**, **`u`** или **`i`**) или неотъемлемая часть преобразования с плавающей запятой (**`f`** или **`F`**) должны быть сгруппированы и разделены тысячами с использованием неденежного разделителя, возвращаемого localeconv(3).

* Необязательный символ-разделитель (**`,`** | **`;`** | **`:`** | **`_`**), используемый для разделения нескольких значений при печати AltiVec или вектор SSE, или другая многозначная единица.  
ПРИМЕЧАНИЕ. Это расширение спецификации **`printf`**(). Поведение этих значений для **`printf`**() определено только для операционных систем, соответствующих Руководству по интерфейсу программирования технологии AltiVec. (На момент написания статьи это касается только Mac OS X 10.2 и более поздних версий.)

* Необязательная строка десятичных цифр, указывающая минимальную ширину поля. Если преобразованное значение имеет меньше символов, чем ширина поля, оно будет дополнено пробелами слева (или справа, если был задан флаг регулировки слева), чтобы заполнить ширину поля.

* Необязательная точность в виде точки **`.`**, за которой следует необязательная цифровая строка. Если строка цифр опущена, точность принимается за ноль. Это дает минимальное количество цифр для отображения **`d`**, **`i`**, **`o`**, **`u`**, **`x`**, и **`X`** преобразования, количество цифр после десятичной точки для **`a`**, **`A`**, **`e`**, **`E`**, **`f`** и **`F`**, максимальное количество значащих цифр для преобразований **`g`** и **`G`** или максимальное число символов, которые будут напечатаны из строки для **`s`** преобразований.

* Необязательный модификатор длины, который определяет размер аргумента. Следующие модификаторы длины действительны для **`d`**, **`i`**, **`n`**, **`o`**, **`u`**, **`x`** или **`X`** преобразование:  
	 **Modifier** | **`d`**, **`i`** | **`o`**, **`u`**, **`x`**, **`X`** | **`n`**
	---- | --- | --- | ---
	 **`hh`** | *`signed char`* | *`unsigned char`* | *`signed char*`*
	 **`h`** | *`short`* | *`unsigned short`* | *`short*`*
	 **`l`** (ell) | *`long`* | *`unsigned long`* | *`long*`*
	 **`ll`** (ell ell) | *`long long`* | *`unsigned long long`* | *`long long*`*
	 **`j`** | *`intmax_t`* | *`uintmax_t`* | *`intmax_t*`*
	 **`t`** | *`ptrdiff_t`* | (see note) | *`ptrdiff_t*`*
	 **`z`** | (see note) | *`size_t`* | (see note)
	 **`q`** *(deprecated)* | *`quad_t`* | *`u_quad_t`* | *`quad_t*`*
	Примечание: модификатор **`t`** при применении к преобразованию **`o`**, **`u`**, **`x`** или **`X`**, указывает, что аргумент имеет тип без знака, эквивалентный по размеру *`ptrdiff_t`*. Модификатор **`z`**, когда применяется к преобразованию **`d`** или **`i`**, указывает, что аргумент имеет тип со знаком, эквивалентный по размеру *`size_t`* , Точно так же, когда применяется к преобразованию **`n`**, это указывает, что аргумент является указателем на тип со знаком, эквивалентный по размеру *`size_t`*.

	Следующий модификатор длины действителен для **`a`**, **`A`**, **`e`**, **`E`**, **`f`**, **`F`**, **`g`** или **`G`** преобразование:  
	 **Modifier** | **`a`**, **`A`**, **`e`**, **`E`**, **`f`**, **`F`**, **`g`**, **`G`**
	--- | ---
	 **`l`** (ell) | *`double`* (ignored, same behavior as without it)
	 **`L`** | *`long double`*

	Следующий модификатор длины действителен для преобразования **`c`** или **`s`**:
	 **Modifier** | **`c`** | **`s`**
	 --- | --- | ---
	 **`l`** (ell) | *`wint_t`* | *`wchar_t*` *
	В Руководстве по интерфейсу программирования технологии AltiVec также определены пять дополнительных модификаторов длины, которые могут использоваться (вместо обычных модификаторов длины) для печати векторов AltiVec или SSE:	

	**`v`**  
		Рассматривайте аргумент как векторное значение; длина единицы будет определяться спецификатором преобразования (по умолчанию = 16 8-битных единиц для всех целочисленных преобразований, 4 32-битных единицы для преобразований с плавающей запятой).

	**`vh`, `hv`**  
		Рассматривайте аргумент как вектор из 8 16-битных единиц.

	**`vl`, `lv`**  
		Рассматривайте аргумент как вектор из 4 32-битных единиц.

	ПРИМЕЧАНИЕ. Спецификаторы длины вектора являются расширением спецификации **`printf`**(). Поведение этих значений для **`printf`**() определено только для операционных систем, соответствующих Руководству по программному интерфейсу технологии AltiVec. (На момент написания статьи это относится только к Mac OS X 10.2 и более поздним версиям).

	В качестве дополнительного расширения для 64-битных модулей SSE2:
	**`vll`, `llv`**
		Рассматривайте аргумент как вектор из 2 64-битных единиц.

* Символ, который указывает тип преобразования, которое будет применено.

Ширина или точность поля, или и то, и другое могут указываться звездочкой '`*`' или звездочкой, за которой следуют одна или несколько десятичных цифр и '`$`' вместо строки цифр. В этом случае аргумент *`int`* предоставляет ширину поля или точность.

Отрицательная ширина поля обрабатывается как левый корректирующий флаг, за которым следует положительная ширина поля; отрицательная точность обрабатывается так, как если бы она отсутствовала. Если директива одного формата смешивает позиционные (`nn$`) и непозиционные аргументы, результаты не определены. Спецификаторы преобразования и их значения:

**`diouxX`**  
	Аргумент *`int`* (или соответствующий вариант) преобразуется в десятичное число со знаком (**`d`** и **`i`**), восьмеричное без знака (**`o`**), десятичная запись без знака (**`u`**) или шестнадцатеричная запись без знака (**`x`** и **`X`**). Буквы "`abcdef`" используются для **`x`** преобразований; буквы "`ABCDEF`" используются для **`X`** преобразований. Точность, если она есть, дает минимальное количество цифр, которые должны появиться; если для преобразованного значения требуется меньше цифр, оно дополняется слева нулями.  

**`DOU`**  
	Аргумент *`long int`* преобразуется в десятичное число со знаком, восьмеричное число без знака или десятичное число без знака, как если бы формат был **`ld`**, **`lo`**, или **`lu`** соответственно. Эти символы преобразования устарели и в конечном итоге исчезнут.

**`eE`**    
	Аргумент *`double`* округляется и преобразуется в стиль *`[-]d.ddde+-dd`*, где перед знаком десятичной точки стоит одна цифра, а после цифры - последовательность цифр обохначающая точность; если точность отсутствует, она принимается за 6; если точность равна нулю, символ десятичной точки не отображается. Преобразование **`E`** использует букву '`E`' (а не '`e`') для представления показателя степени. Экспонента всегда содержит как минимум две цифры; если значение равно нулю, показатель степени равен 00.  

  Для **`a`**, **`A`**, **`e`**, **`E`**, **`f`**, **`F`**, **`g`** и **`G`**, положительная и отрицательная бесконечность представляются как `inf` и `-inf` соответственно при использовании символа преобразования в нижнем регистре, а также `INF` и `-INF` соответственно при использовании символа преобразования в верхнем регистре. Аналогично, `NaN` представляется как `nan` при использовании преобразования в нижнем регистре, и как `NAN` при использовании преобразования в верхнем регистре.

**`fF`**  
	Аргумент *`double`* округляется и преобразуется в десятичную запись в стиле `[-]ddd.ddd`, где количество цифр после символа десятичной точки равно к спецификации точности. Если точность отсутствует, она принимается за 6; если точность явно равна нулю, символ десятичной точки не появляется. Если появляется десятичная точка, перед ней должна быть хотя бы одна цифра.

**`gG`**  
	Аргумент *`double`* преобразуется в стиль **`f`** или **`e`** (или **`F`** или **`E`** для **`G`** преобразований). Точность определяет количество значащих цифр. Если точность отсутствует, дается 6 цифр; если точность равна нулю, она обрабатывается как 1. Стиль **`e`** используется, если показатель степени от его преобразования меньше -4 или больше или равен точности. Замыкающие нули удаляются из дробной части результата; десятичная точка появляется, только если за ней следует хотя бы одна цифра.

**`aA`**  
Аргумент *`double`* округляется и преобразуется в шестнадцатеричное представление в стиле `[-]0xh.hhhp[+-]d`, где количество цифр после шестнадцатеричной точки символ равен точности спецификации. Если точность отсутствует, она берется как достаточная для точного представления числа с плавающей запятой, и округления не происходит. Если точность равна нулю, символ шестнадцатеричной точки не отображается. **`p`** является буквальным символом '`p`', а показатель степени состоит из положительного или отрицательного знака, за которым следует десятичное число, представляющее показатель степени 2. Преобразование **`A`** использует префикс '`0X`' (вместо '`0x`'), буквы '`ABCDEF`' (вместо '`abcdef`') для представления шестнадцатеричных цифр и буква '`P`' (вместо '`p`'), чтобы отделить мантиссу и показатель степени.

Обратите внимание, что может быть несколько допустимых способов представления чисел с плавающей точкой в ​​этом шестнадцатеричном формате. Например, `0x1.92p+1`, `0x3.24p+0`, `0x6.48p-1` и `0xc.9p-2` являются эквивалентными. Выбранный формат зависит от внутреннего представления числа, но реализация гарантирует, что длина мантиссы будет минимизирована. Нули всегда представлены с мантиссой 0 (с предшествующим '`-`', если это уместно) и показателем '`+0`'.

**`C`**  
Обрабатывается как **`c`** с модификатором **`l`** (ell).

**`c`**  
Аргумент *`int`* преобразуется в *`unsigned char`*, и результирующий символ записывается.

Если используется модификатор **`l`** (ell), аргумент *`wint_t`* должен быть преобразован в *`wchar_t`*, и записывается (потенциально многобайтовая) последовательность, представляющая один широкий символ , включая любые последовательности сдвига. Если используется последовательность сдвига, состояние сдвига также восстанавливается до исходного состояния после символа.

**`S`**  
Рассматривается как **`s`** с модификатором **`l`** (ell).

**`s`**  
Предполагается, что аргумент *`char *`* будет указателем на массив символьного типа (указатель на строку). Символы из массива записываются до (но не включая) завершающего символа `NUL`; если указана точность, записывается не более указанного числа. Если задана точность, нет нужды в символе; если точность не указана или превышает размер массива, массив должен содержать завершающий символ `NUL`.
Если используется модификатор **`l`** (ell), ожидается, что аргумент *`wchar_t *`* будет указателем на массив широких символов (указатель на широкую строку). Для каждого широкого символа в строке записывается (потенциально многобайтовая) последовательность, представляющая широкий символ, включая любые последовательности сдвига. Если используется какая-либо последовательность сдвигов, состояние сдвига также восстанавливается до исходного состояния после строки. Широкие символы из массива записываются до (но не включая) завершающего широкого символа `NUL`; если указана точность, записывается не более указанного количества байтов (включая последовательности сдвигов). Частичные символы никогда не пишутся. Если задана точность, нет нужды в символе; если точность не указана или превышает число байтов, необходимое для рендеринга многобайтового представления строки, массив должен содержать завершающий широкий символ `NUL`.

**`p`**  
Аргумент указателя *`void *`* печатается в шестнадцатеричном формате (как будто "`%#x`" или "`%#lx`").

**`n`**  
Количество написанных символов сохраняется в целом числе, указанном аргументом указателя *`int *`* (или его вариант). Ни один аргумент не преобразуется.

**`%`**  
A '`%`' написано. Ни один аргумент не преобразуется. Полная спецификация преобразования: '`%%`'.

Символ десятичной точки определяется в локали программы (категория `LC_NUMERIC`).

Ни в коем случае несуществующая или небольшая ширина поля не вызывает усечение числового поля; если результат преобразования шире, чем ширина поля, поле расширяется, чтобы содержать результат преобразования.

# ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Эти функции возвращают количество напечатанных символов (не включая завершающий символ `\0`, используемый для завершения вывода в строки), за исключением **`snprintf`**() и **`vsnprintf`**(), которые вернуть количество символов, которое было бы напечатано, если бы *`size`* был неограниченным (опять же, не считая финального '`\0`'). Эти функции возвращают отрицательное значение в случае ошибки.

# ПРИМЕРЫ
Чтобы напечатать дату и время в виде "`воскресенье, 3 июля, 10:02`", где *`weekday`* и *`month`* - указатели на строки:
```C
	#include <stdio.h>
	fprintf(stdout, "%s, %s %d, %.2d:%.2d\n",
		weekday, month, day, hour, min);
```
Чтобы напечатать число Пи до пяти десятичных знаков:
```C
	#include <math.h>
	#include <stdio.h>
	fprintf(stdout, "pi = %.5f\n", 4 * atan(1.0));
```
Чтобы выделить 128-байтовую строку и вывести в нее:
```C
	#include <stdio.h>
	#include <stdlib.h>
	#include <stdarg.h>
	char *newfmt(const char *fmt, ...)
	{
		char *p;
		va_list ap;
		if ((p = malloc(128)) == NULL)
			return (NULL);
		va_start(ap, fmt);
		(void) vsnprintf(p, 128, fmt, ap);
		va_end(ap);
		return (p);
	}
```
# СОВМЕСТИМОСТЬ
Форматы преобразования **`%D`**, **`%O`** и **`%U`** не являются стандартными и предоставляются только для обратной совместимости. Эффект заполнения формата **`%p`** нулями (либо с помощью флага **`0`**, либо путем указания точности), и доброкачественный эффект (т. Е. Ни одного) **`#`** Флаг на **`%n`** и **`%p`** преобразованиях, а также другие бессмысленные комбинации, такие как **`%Ld`**, не являются стандартными; таких комбинаций следует избегать.

# ОШИБКИ
В дополнение к ошибкам, задокументированным для системного вызова write(2), семейство функций **`printf`**() может завершиться ошибкой, если:

   .|  | 
   --- | ---  
[`EILSEQ`] | An invalid wide character code was encountered.
[`ENOMEM`] | Insufficient storage space is available.

# СМОТРИТЕ ТАКЖЕ
**printf**(1), **printf_l**(3), **fmtcheck**(3), **scanf**(3), **setlocale**(3), **stdarg**(3), **wprintf**(3)

# СТАНДАРТЫ
С учетом предостережений, указанных в разделе *`BUGS`* ниже, **`fprintf`**(), **`printf`**(), **`sprintf`**(), **`vprintf Функции`**(), **`vfprintf`**() и **`vsprintf`**() соответствуют ANSI X3.159-1989 ("ANSIC89") и ISO/IEC 9899:1999 ("ISOС99"). С той же оговоркой функции **`snprintf`**() и **`vsnprintf`**() соответствуют ISO/IEC 9899:1999 ("ISOC99"), тогда как **`dprintf`**() и **`vdprintf`**() соответствуют стандарту IEEE 1003.1-2008 ("POSIX.1").

# ИСТОРИЯ
Функции **`asprintf`**() и **`vasprintf`**() впервые появились в библиотеке `GNU C`. Они были реализованы Питером Веммом <[peter@FreeBSD.org] (mailto:peter@FreeBSD.org)> во FreeBSD 2.2, но позже были заменены на реализацию, отличную от OpenBSD 2.3 Тоддом С. Миллером <[Todd.Miller@courtesan.com] (mailto:Todd.Miller@courtesan.com)>. Функции **`dprintf`**() и **`vdprintf`**() были добавлены в FreeBSD 8.0.

# Ошибки

Семейство функций **`printf`** неправильно обрабатывает многобайтовые символы в аргументе *`format`*.

# СООБРАЖЕНИЯ БЕЗОПАСНОСТИ

Функции **`sprintf`**() и **`vsprintf`**() легко используются неправильно, что позволяет злонамеренным пользователям произвольно изменять функциональность работающей программы через атаку переполнения буфера. Поскольку **`sprintf`**() и **`vsprintf`**() предполагают бесконечно длинную строку, вызывающие объекты должны быть осторожны, чтобы не переполнить фактическое пространство; это часто трудно гарантировать. Для безопасности программисты должны использовать интерфейс **`snprintf`**().
Например:
```C
	void
	foo(const char *arbitrary_string, const char *and_another)
	{
		char onstack[8];
	
	#ifdef BAD
		/*
		 * This first sprintf is bad behavior.  Do not use sprintf!
		 */
		sprintf(onstack, "%s, %s", arbitrary_string, and_another);
	#else
		/*
		 * The following two lines demonstrate better use of
		 * snprintf().
		 */
		snprintf(onstack, sizeof(onstack), "%s, %s", arbitrary_string,
		    and_another);
	#endif
	}
```
Семейство функций **`printf`**() и **`sprintf`**() также легко используется неправильно, позволяя злонамеренным пользователям произвольно изменять функциональность работающей программы, заставляя программу печатать потенциально важные данные "оставленный в стеке" или вызывающий ошибку памяти или шины путем разыменования недопустимого указателя.

**`%n`** можно использовать для записи произвольных данных в потенциально тщательно отобранные адреса. Поэтому программистам настоятельно рекомендуется никогда не передавать ненадежные строки в качестве аргумента *`format`*, поскольку злоумышленник может поместить в строку спецификаторы формата, чтобы исказить ваш стек, что приведет к возможной дыре в безопасности. Это верно даже в том случае, если строка была построена с использованием функции, подобной **`snprintf`**(), поскольку полученная строка все еще может содержать предоставленные пользователем спецификаторы преобразования для последующей интерполяции с помощью **`printf`**().

Всегда используйте правильную идиому:
```C
	snprintf(buffer, sizeof(buffer), "%s", string);
```
Mac OS X 10.12 - December 2, 2009
